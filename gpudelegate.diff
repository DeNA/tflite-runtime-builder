diff --git a/tensorflow/lite/delegates/gpu/delegate.cc b/tensorflow/lite/delegates/gpu/delegate.cc
index e1728e826eb..c65b7bf9f2b 100644
--- a/tensorflow/lite/delegates/gpu/delegate.cc
+++ b/tensorflow/lite/delegates/gpu/delegate.cc
@@ -119,7 +119,22 @@ class Delegate {
   int MaxDelegatedPartitions() const {
     return options_.max_delegated_partitions;
   }
+  void BindInputBuffer(uint32_t index, GLuint ssbo_id) {
+    external_input_buffers_[index] = ssbo_id;
+  }
+  void BindOutputBuffer(uint32_t index, GLuint ssbo_id) {
+    external_output_buffers_[index] = ssbo_id;
+  }
   int num_delegate_kernels() const { return num_delegate_kernels_; }
+  absl::flat_hash_map<uint32_t, GLuint> external_input_buffers_;
+  absl::flat_hash_map<uint32_t, GLuint> external_output_buffers_;
+
+  bool HasExternalInputBuffer(int index) {
+    return external_input_buffers_.count(index) > 0;
+  }
+  bool HasExternalOutputBuffer(int index) {
+    return external_output_buffers_.count(index) > 0;
+  }
 
  private:
   TfLiteDelegate delegate_;
@@ -148,8 +163,16 @@ class DelegateKernel {
     GraphFloat32 graph;
     std::vector<uint32_t> input_refs;
     std::vector<uint32_t> output_refs;
-    RETURN_IF_ERROR(InitializeGraph(context, delegate_params, &graph,
+    std::vector<BHWC> input_shapes;
+    std::vector<BHWC> output_shapes;
+      RETURN_IF_ERROR(InitializeGraph(context, delegate_params, &graph,
                                     &input_refs, &output_refs));
+    for (const auto& input : graph.inputs()) {
+      input_shapes.push_back(input->tensor.shape);
+    }
+    for (const auto& output : graph.outputs()) {
+      output_shapes.push_back(output->tensor.shape);
+    }
 
     std::unique_ptr<InferenceBuilder> builder;
     bool graph_is_destroyed;
@@ -188,8 +211,12 @@ class DelegateKernel {
       input_indices_.push_back(tensor_index);
       const TfLiteTensor& tflite_tensor = context->tensors[tensor_index];
       const DataType data_type = ToDataType(tflite_tensor.type);
+      bool is_external = delegate_->HasExternalInputBuffer(object_index);
+      const ObjectDef& object_def = is_external
+        ? GetGpuObjectDef(input_shapes[object_index].c)
+        : GetObjectDef(tensor_index, data_type);
       RETURN_IF_ERROR(builder->SetInputObjectDef(
-          object_index, GetObjectDef(tensor_index, data_type)));
+          object_index, object_def));
     }
     output_indices_.reserve(output_refs.size());
     for (uint32_t tensor_index : output_refs) {
@@ -197,8 +224,12 @@ class DelegateKernel {
       output_indices_.push_back(tensor_index);
       const TfLiteTensor& tflite_tensor = context->tensors[tensor_index];
       const DataType data_type = ToDataType(tflite_tensor.type);
+      bool is_external = delegate_->HasExternalOutputBuffer(object_index);
+      const ObjectDef& object_def = is_external
+        ? GetGpuObjectDef(input_shapes[object_index].c)
+        : GetObjectDef(tensor_index, data_type);
       RETURN_IF_ERROR(builder->SetOutputObjectDef(
-          object_index, GetObjectDef(tensor_index, data_type)));
+          object_index, object_def));
     }
 
     return builder->Build(&runner_);
@@ -256,12 +287,29 @@ class DelegateKernel {
  private:
   absl::Status SetInputsAndOutputs(TfLiteContext* context) {
     for (int i = 0; i < input_indices_.size(); ++i) {
-      RETURN_IF_ERROR(runner_->SetInputObject(
-          i, GetTensorObject(input_indices_[i], context)));
+      bool is_external = delegate_->HasExternalInputBuffer(i);
+      if (is_external)
+      {
+        OpenGlBuffer buffer = OpenGlBuffer(delegate_->external_input_buffers_[i]);
+        RETURN_IF_ERROR(runner_->SetInputObject(i, buffer));
+      }
+      else {
+        RETURN_IF_ERROR(runner_->SetInputObject(
+            i, GetTensorObject(input_indices_[i], context)));
+      }
     }
+
     for (int i = 0; i < output_indices_.size(); ++i) {
-      RETURN_IF_ERROR(runner_->SetOutputObject(
-          i, GetTensorObject(output_indices_[i], context)));
+      bool is_external = delegate_->HasExternalOutputBuffer(i);
+      if (is_external)
+      {
+        OpenGlBuffer buffer = OpenGlBuffer(delegate_->external_output_buffers_[i]);
+        RETURN_IF_ERROR(runner_->SetOutputObject(i, buffer));
+      }
+      else {
+        RETURN_IF_ERROR(runner_->SetOutputObject(
+            i, GetTensorObject(output_indices_[i], context)));
+      }
     }
     return absl::OkStatus();
   }
@@ -281,6 +329,17 @@ class DelegateKernel {
     return MakeCpuMemory(absl::MakeSpan(tensor.data.raw, tensor.bytes));
   }
 
+  ObjectDef GetGpuObjectDef(int channels) const { 
+    ObjectDef gpu_object_def;
+    gpu_object_def.data_type = DataType::FLOAT32;
+    gpu_object_def.data_layout = channels == 4
+      ? DataLayout::DHWC4
+      : DataLayout::BHWC;
+    gpu_object_def.object_type = ObjectType::OPENGL_SSBO;
+    gpu_object_def.user_provided = true;
+    return gpu_object_def;
+  }  
+
  private:
   absl::Status InitializeGraph(TfLiteContext* context,
                                const TfLiteDelegateParams* delegate_params,
@@ -619,3 +678,23 @@ TfLiteDelegate* TfLiteGpuDelegateV2Create(
 void TfLiteGpuDelegateV2Delete(TfLiteDelegate* delegate) {
   delete tflite::gpu::GetDelegate(delegate);
 }
+
+TfLiteStatus TfLiteGpuDelegateV2BindInputBuffer(
+  TfLiteDelegate* delegate, int index, GLuint buffer) {
+  auto* gpu_delegate = tflite::gpu::GetDelegate(delegate);
+  if (!gpu_delegate) {
+    return kTfLiteDelegateError;
+  }
+  gpu_delegate->BindInputBuffer(index, buffer);
+  return kTfLiteOk;
+}
+
+TfLiteStatus TfLiteGpuDelegateV2BindOutputBuffer(
+  TfLiteDelegate* delegate, int index, GLuint buffer) {
+  auto* gpu_delegate = tflite::gpu::GetDelegate(delegate);
+  if (!gpu_delegate) {
+    return kTfLiteDelegateError;
+  }
+  gpu_delegate->BindOutputBuffer(index, buffer);
+  return kTfLiteOk;
+}
diff --git a/tensorflow/lite/delegates/gpu/delegate.h b/tensorflow/lite/delegates/gpu/delegate.h
index 3a1e1811478..f6bf531eb88 100644
--- a/tensorflow/lite/delegates/gpu/delegate.h
+++ b/tensorflow/lite/delegates/gpu/delegate.h
@@ -156,6 +156,19 @@ TFL_CAPI_EXPORT TfLiteDelegate* TfLiteGpuDelegateV2Create(
 // Destroys a delegate created with `TfLiteGpuDelegateV2Create` call.
 TFL_CAPI_EXPORT void TfLiteGpuDelegateV2Delete(TfLiteDelegate* delegate);
 
+typedef uint32_t GLuint;
+// Binds GL shader storage object to an input in the initialized
+// delegate. Bound buffer should have sufficient storage to accommodate
+// all elements of a tensor.
+TFL_CAPI_EXPORT TfLiteStatus TfLiteGpuDelegateV2BindInputBuffer(
+  TfLiteDelegate* delegate, int index, GLuint buffer);
+
+// Binds GL shader storage object to an output in the initialized
+// delegate. Bound buffer should have sufficient storage to accommodate
+// all elements of a tensor.
+TFL_CAPI_EXPORT TfLiteStatus TfLiteGpuDelegateV2BindOutputBuffer(
+  TfLiteDelegate* delegate, int index, GLuint buffer);
+
 #ifdef __cplusplus
 }
 #endif  // __cplusplus
